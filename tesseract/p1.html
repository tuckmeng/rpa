<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>PaddleOCR Full Pipeline Browser Demo (Accurate DB PostProcess)</title>
<script src="https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/ort.min.js"></script>
<style>
body { font-family: sans-serif; padding: 20px; }
textarea { width: 100%; height: 160px; margin-top: 15px; }
#imgPreview { max-width: 400px; margin-top: 15px; display: block; }
</style>
</head>
<body>

<h2>PaddleOCR Browser Demo â€” Accurate DB PostProcess</h2>
<input type="file" id="fileInput" accept="image/*"/>
<img id="imgPreview"/>
<textarea id="resultBox" placeholder="Recognized text will appear here..."></textarea>

<script>
let detSession, recSession;
let dict = [];

// --- Load dictionary ---
async function loadDictionary(){
    const txt = await fetch("ppocr_keys_en.txt").then(r=>r.text());
    dict = txt.split("\n").map(s=>s.trim()).filter(s=>s.length>0);
}

// --- Load ONNX models ---
async function loadModels(){
    detSession = await ort.InferenceSession.create("ch_PP-OCRv3_det_infer.onnx");
    recSession = await ort.InferenceSession.create("ch_PP-OCRv3_rec_infer.onnx");
}

// --- Image preprocessing ---
function resizeImage(imgBitmap, targetH){
    const ratio = targetH / imgBitmap.height;
    const w = Math.round(imgBitmap.width * ratio);
    const canvas = new OffscreenCanvas(w,targetH);
    const ctx = canvas.getContext("2d");
    ctx.drawImage(imgBitmap,0,0,w,targetH);
    return canvas;
}

function getImageTensor(canvas){
    const ctx = canvas.getContext("2d");
    const { width, height } = canvas;
    const imgData = ctx.getImageData(0,0,width,height).data;
    const arr = new Float32Array(1*3*height*width);
    let p=0;
    for(let i=0;i<imgData.length;i+=4){
        arr[p++] = imgData[i]/255;
        arr[p++] = imgData[i+1]/255;
        arr[p++] = imgData[i+2]/255;
    }
    return new ort.Tensor("float32",arr,[1,3,height,width]);
}

// --- Accurate DB PostProcess (polygon extraction) ---
function dbPostProcess(predMap, bitmapWidth, bitmapHeight, thresh=0.3, boxThresh=0.5){
    // predMap: {data:Float32Array, dims:[1,1,H,W]}
    const H = predMap.dims[2], W = predMap.dims[3];
    const map = predMap.data;
    // Convert Float32Array to 2D array
    const mat = [];
    for(let y=0;y<H;y++){
        const row=[];
        for(let x=0;x<W;x++){
            row.push(map[y*W+x]);
        }
        mat.push(row);
    }

    // --- Binarize ---
    const binary = mat.map(row=>row.map(v=>v>thresh?1:0));

    // --- Connected Components (simple flood fill) ---
    const labels = [];
    for(let y=0;y<H;y++){
        labels.push(new Array(W).fill(0));
    }
    let labelCount=0;
    function floodFill(x,y,label){
        const stack=[[x,y]];
        while(stack.length){
            const [cx,cy]=stack.pop();
            if(cx<0||cy<0||cx>=W||cy>=H) continue;
            if(binary[cy][cx]===0 || labels[cy][cx]!==0) continue;
            labels[cy][cx]=label;
            stack.push([cx+1,cy]);
            stack.push([cx-1,cy]);
            stack.push([cx,cy+1]);
            stack.push([cx,cy-1]);
        }
    }
    for(let y=0;y<H;y++){
        for(let x=0;x<W;x++){
            if(binary[y][x]===1 && labels[y][x]===0){
                labelCount++;
                floodFill(x,y,labelCount);
            }
        }
    }

    // --- Extract bounding boxes from labels ---
    const boxes = [];
    for(let l=1;l<=labelCount;l++){
        let minX=W,maxX=0,minY=H,maxY=0;
        for(let y=0;y<H;y++){
            for(let x=0;x<W;x++){
                if(labels[y][x]===l){
                    minX=Math.min(minX,x);
                    maxX=Math.max(maxX,x);
                    minY=Math.min(minY,y);
                    maxY=Math.max(maxY,y);
                }
            }
        }
        const boxW = maxX-minX;
        const boxH = maxY-minY;
        if(boxW*boxH/(W*H) < boxThresh) continue; // skip small
        // scale back to original bitmap
        const scaleX = bitmapWidth/W;
        const scaleY = bitmapHeight/H;
        boxes.push([
            [minX*scaleX,minY*scaleY],
            [maxX*scaleX,minY*scaleY],
            [maxX*scaleX,maxY*scaleY],
            [minX*scaleX,maxY*scaleY]
        ]);
    }

    // Sort boxes top-to-bottom, left-to-right
    boxes.sort((a,b)=>{
        if(a[0][1]!==b[0][1]) return a[0][1]-b[0][1];
        return a[0][0]-b[0][0];
    });

    return boxes;
}

// --- Recognize single box ---
async function recognizeBox(boxCanvas){
    const targetH=32;
    const ratio=targetH/boxCanvas.height;
    const targetW=Math.round(boxCanvas.width*ratio);
    const canvas=new OffscreenCanvas(targetW,targetH);
    const ctx=canvas.getContext("2d");
    ctx.drawImage(boxCanvas,0,0,targetW,targetH);
    const tensor=getImageTensor(canvas);
    const output=await recSession.run({x:tensor});
    const logits=output.RecPredictor.data;
    const [seqLen,numClasses]=output.RecPredictor.dims;

    let text="";
    let prev=-1;
    for(let t=0;t<seqLen;t++){
        let maxC=0,maxV=-Infinity;
        for(let c=0;c<numClasses;c++){
            const v=logits[t*numClasses+c];
            if(v>maxV){ maxV=v; maxC=c; }
        }
        if(maxC!==prev && maxC>0 && maxC-1<dict.length){
            text += dict[maxC-1];
        }
        prev=maxC;
    }
    return text;
}

// --- Handle uploaded file ---
async function handleFile(file){
    const img=document.getElementById("imgPreview");
    img.src=URL.createObjectURL(file);
    const bitmap=await createImageBitmap(file);

    // Detection
    const targetH=640;
    const detCanvas=resizeImage(bitmap,targetH);
    const detTensor=getImageTensor(detCanvas);
    const detOut=await detSession.run({x:detTensor});
    const predMap=detOut.sigmoid_0;

    const boxes=dbPostProcess(predMap,bitmap.width,bitmap.height);

    let resultText="";
    for(const box of boxes){
        const minX=Math.min(...box.map(p=>p[0])), minY=Math.min(...box.map(p=>p[1]));
        const maxX=Math.max(...box.map(p=>p[0])), maxY=Math.max(...box.map(p=>p[1]));
        const w=maxX-minX, h=maxY-minY;
        const canvas=new OffscreenCanvas(w,h);
        const ctx=canvas.getContext("2d");
        ctx.drawImage(bitmap,minX,minY,w,h,0,0,w,h);
        const txt=await recognizeBox(canvas);
        resultText += txt+"\n";
    }

    document.getElementById("resultBox").value=resultText.trim();
}

document.getElementById("fileInput").addEventListener("change",(e)=>handleFile(e.target.files[0]));

(async()=>{
    await loadDictionary();
    await loadModels();
})();
</script>
</body>
</html>
